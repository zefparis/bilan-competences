import { NextRequest, NextResponse } from "next/server"
import { prisma } from "@/lib/prisma"
import { getUserIdFromRequest } from "@/lib/auth-user"
import { generateGeneralReport, generateFallbackReport } from "@/lib/general-report-sections"
import type { CognitiveReportSections } from "@/lib/report-mapping"

export const dynamic = "force-dynamic"
export const maxDuration = 60

export async function POST(req: NextRequest) {
  try {
    const userId = await getUserIdFromRequest(req)

    if (!userId) {
      return NextResponse.json({ message: "Non authentifié" }, { status: 401 })
    }

    // Check if user has paid
    const user = await (prisma as any).user.findUnique({
      where: { id: userId },
      select: {
        id: true,
        name: true,
        hasPaid: true,
      },
    })

    if (!user?.hasPaid) {
      return NextResponse.json({ message: "Accès non autorisé" }, { status: 403 })
    }

    // Fetch cognitive session
    console.log("[REPORT-GEN] Fetching COMPLETED cognitive session for user:", userId);
    let cognitiveSession = null
    let assessment = null
    
    try {
      cognitiveSession = await (prisma as any).cognitiveTestSession.findFirst({
        where: { userId, status: "COMPLETED" },
        orderBy: { completedAt: "desc" },
        include: { signature: true },
      })
      console.log("[REPORT-GEN] Cognitive session found:", !!cognitiveSession, "Signature:", !!cognitiveSession?.signature);
    } catch (e: any) {
      console.error("[REPORT-GEN] Error fetching cognitive session:", e?.message)
    }

    // Fetch assessment data
    console.log("[REPORT-GEN] Fetching assessment data...");
    try {
      assessment = await (prisma as any).assessment.findFirst({
        where: { userId },
        orderBy: { createdAt: "desc" },
        include: {
          riasecResult: true,
          userValues: { orderBy: { order: "asc" }, take: 10 },
          experiences: { orderBy: { createdAt: "desc" }, take: 5 },
          lifePath: {
            include: {
              events: { orderBy: { year: "desc" }, take: 10 },
            },
          },
        },
      })
      console.log("[REPORT-GEN] Assessment found:", !!assessment);
    } catch (e: any) {
      console.error("[REPORT-GEN] Error fetching assessment:", e?.message)
    }

    const riasecResult = assessment?.riasecResult
    const values = assessment?.userValues
    const experiences = assessment?.experiences
    const lifeEvents = assessment?.lifePath?.events

    if (!cognitiveSession?.signature) {
      console.warn("[REPORT-GEN] Missing cognitive signature, aborting.");
      return NextResponse.json(
        { message: "Évaluation cognitive non complétée. Veuillez d'abord compléter les 4 tests cognitifs." },
        { status: 400 }
      )
    }

    // Prepare input data
    console.log("[REPORT-GEN] Preparing report input...");
    const reportInput = {
      cognitiveSignature: cognitiveSession.signature,
      riasec: riasecResult ? {
        R: riasecResult.scoreR || 0,
        I: riasecResult.scoreI || 0,
        A: riasecResult.scoreA || 0,
        S: riasecResult.scoreS || 0,
        E: riasecResult.scoreE || 0,
        C: riasecResult.scoreC || 0
      } : undefined,
      userName: user.name,
      values: values?.map(v => ({ name: v.valueName, priority: v.order })),
      experiences: experiences?.map(e => ({
        title: e.title,
        situation: e.situation || "",
        task: e.task || "",
        action: e.action || "",
        result: e.result || "",
        competences: e.skills ? e.skills.split(",").map(s => s.trim()) : []
      })),
      lifeEvents: lifeEvents?.map(e => ({
        title: e.title,
        date: String(e.year) || "",
        type: e.type || "",
        description: e.description || ""
      }))
    }

    let report: CognitiveReportSections;
    
    try {
      report = generateGeneralReport(reportInput)
    } catch (error) {
      console.error("Erreur génération rapport:", error)
      report = generateFallbackReport({
        cognitiveSignature: cognitiveSession.signature,
        userName: user.name
      })
    }

    // Store the report
    console.log("[REPORT-GEN] Storing report in database for session:", cognitiveSession.id);
    await (prisma as any).cognitiveTestSession.update({
      where: { id: cognitiveSession.id },
      data: {
        generatedReport: JSON.parse(JSON.stringify(report)), // Ensure it's a plain object
      },
    })

    console.log("[REPORT-GEN] Generation complete.");
    return NextResponse.json(report)
  } catch (error) {
    console.error("[Report Generate] Error:", error)
    return NextResponse.json(
      { message: error?.message || "Erreur lors de la génération du rapport" },
      { status: 500 }
    )
  }
}

export async function GET(req: NextRequest) {
  try {
    const userId = await getUserIdFromRequest(req)

    if (!userId) {
      return NextResponse.json({ message: "Non authentifié" }, { status: 401 })
    }

    // Get latest session with report
    const session = await (prisma as any).cognitiveTestSession.findFirst({
      where: { 
        userId, 
        status: "COMPLETED",
        generatedReport: { not: null },
      },
      orderBy: { completedAt: "desc" },
      select: {
        id: true,
        generatedReport: true,
        completedAt: true,
      },
    })

    if (!session?.generatedReport) {
      return NextResponse.json(
        { message: "Aucun rapport disponible" },
        { status: 404 }
      )
    }

    return NextResponse.json({
      sessionId: session.id,
      report: session.generatedReport,
      completedAt: session.completedAt,
    })
  } catch (error) {
    console.error("[Report Get] Error:", error)
    return NextResponse.json(
      { message: "Erreur lors de la récupération du rapport" },
      { status: 500 }
    )
  }
}
